<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gesture Particle Universe</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  overflow: hidden;
  background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

#canvas-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

#video {
  position: fixed;
  top: 10px;
  right: 10px;
  width: 160px;
  height: 120px;
  border: 2px solid rgba(0, 255, 255, 0.3);
  border-radius: 8px;
  display: none;
  z-index: 100;
}

.hud {
  position: fixed;
  top: 20px;
  left: 20px;
  color: rgba(0, 255, 255, 0.9);
  font-size: 14px;
  background: rgba(0, 0, 0, 0.5);
  padding: 15px 20px;
  border-radius: 10px;
  border: 1px solid rgba(0, 255, 255, 0.3);
  backdrop-filter: blur(10px);
  z-index: 100;
  font-family: 'Courier New', monospace;
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
}

.hud-item {
  margin: 5px 0;
  display: flex;
  justify-content: space-between;
  gap: 15px;
}

.hud-label {
  opacity: 0.7;
}

.hud-value {
  font-weight: bold;
  color: #00ffff;
  text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
}

.controls {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255, 255, 255, 0.8);
  font-size: 12px;
  background: rgba(0, 0, 0, 0.6);
  padding: 12px 20px;
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  z-index: 100;
  text-align: center;
}

.controls div {
  margin: 3px 0;
}

@keyframes pulse {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}

.pulse {
  animation: pulse 2s infinite;
}

#loading {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #00ffff;
  font-size: 18px;
  text-align: center;
  z-index: 200;
  text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
}
</style>
</head>
<body>
<div id="canvas-container"></div>
<video id="video" autoplay playsinline></video>

<div class="hud">
  <div class="hud-item">
    <span class="hud-label">SHAPE:</span>
    <span class="hud-value" id="shape-display">GALAXY</span>
  </div>
  <div class="hud-item">
    <span class="hud-label">GESTURE:</span>
    <span class="hud-value" id="gesture-display">NONE</span>
  </div>
  <div class="hud-item">
    <span class="hud-label">FPS:</span>
    <span class="hud-value" id="fps-display">60</span>
  </div>
  <div class="hud-item">
    <span class="hud-label">PARTICLES:</span>
    <span class="hud-value" id="particle-count">50000</span>
  </div>
</div>

<div class="controls">
  <div><strong>KEYBOARD:</strong> 1=Heart | 2=Flower | 3=Saturn | 4=Fireworks | 5=Galaxy</div>
  <div><strong>GESTURES:</strong> Open/Close Hand = Expand/Contract | Move = Swirl | Two Hands = Morph</div>
  <div class="pulse">Wave hand to activate gesture control</div>
</div>

<div id="loading">INITIALIZING PARTICLE UNIVERSE...</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.getElementById('canvas-container').appendChild(renderer.domElement);

camera.position.z = 50;

// Particle system
const PARTICLE_COUNT = 50000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT * 3);
const colors = new Float32Array(PARTICLE_COUNT * 3);
const sizes = new Float32Array(PARTICLE_COUNT);
const velocities = new Float32Array(PARTICLE_COUNT * 3);

// Particle state
let currentShape = 'galaxy';
let targetShape = 'galaxy';
let morphProgress = 0;
let gestureIntensity = 0;
let handDistance = 0.5;
let swirl = 0;
let expansion = 1;

// Shape generators
const shapes = {
  heart: (i, total) => {
    const t = (i / total) * Math.PI * 2;
    const r = Math.random() * 5 + 10;
    const x = r * 16 * Math.pow(Math.sin(t), 3);
    const y = r * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
    const z = (Math.random() - 0.5) * 10;
    return [x * 0.5, y * 0.5, z];
  },
  
  flower: (i, total) => {
    const angle = (i / total) * Math.PI * 2 * 8;
    const radius = 15 * Math.sin(5 * angle) * (i / total);
    const x = radius * Math.cos(angle);
    const y = radius * Math.sin(angle);
    const z = (Math.random() - 0.5) * 5;
    return [x, y, z];
  },
  
  saturn: (i, total) => {
    if (i < total * 0.7) {
      // Planet sphere
      const phi = Math.acos(2 * Math.random() - 1);
      const theta = Math.random() * Math.PI * 2;
      const r = 15 + (Math.random() - 0.5) * 2;
      const x = r * Math.sin(phi) * Math.cos(theta);
      const y = r * Math.sin(phi) * Math.sin(theta);
      const z = r * Math.cos(phi);
      return [x, y, z];
    } else {
      // Ring
      const angle = Math.random() * Math.PI * 2;
      const radius = 20 + Math.random() * 10;
      const x = radius * Math.cos(angle);
      const z = radius * Math.sin(angle);
      const y = (Math.random() - 0.5) * 1;
      return [x, y, z];
    }
  },
  
  fireworks: (i, total) => {
    const burstCount = 5;
    const burst = Math.floor(i / (total / burstCount));
    const angle = (i % (total / burstCount)) / (total / burstCount) * Math.PI * 2;
    const radius = (i % (total / burstCount)) / (total / burstCount) * 30;
    
    const centerX = (burst % 3 - 1) * 20;
    const centerY = Math.floor(burst / 3) * 20 - 10;
    
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    const z = (Math.random() - 0.5) * 10;
    return [x, y, z];
  },
  
  galaxy: (i, total) => {
    const angle = (i / total) * Math.PI * 4 + Math.random() * 0.5;
    const radius = (i / total) * 40 + Math.random() * 5;
    const arms = 3;
    const armAngle = (i % arms) * (Math.PI * 2 / arms);
    
    const x = radius * Math.cos(angle + armAngle);
    const y = radius * Math.sin(angle + armAngle);
    const z = (Math.random() - 0.5) * 5 * (1 - i / total);
    return [x, y, z];
  }
};

// Initialize particles
function initializeParticles(shapeName) {
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const [x, y, z] = shapes[shapeName](i, PARTICLE_COUNT);
    const i3 = i * 3;
    
    positions[i3] = x;
    positions[i3 + 1] = y;
    positions[i3 + 2] = z;
    
    const color = new THREE.Color();
    color.setHSL((i / PARTICLE_COUNT) * 0.3 + 0.5, 1, 0.5 + gestureIntensity * 0.3);
    colors[i3] = color.r;
    colors[i3 + 1] = color.g;
    colors[i3 + 2] = color.b;
    
    sizes[i] = Math.random() * 2 + 1;
    
    velocities[i3] = (Math.random() - 0.5) * 0.1;
    velocities[i3 + 1] = (Math.random() - 0.5) * 0.1;
    velocities[i3 + 2] = (Math.random() - 0.5) * 0.1;
  }
}

initializeParticles(currentShape);

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

const material = new THREE.PointsMaterial({
  size: 2,
  vertexColors: true,
  blending: THREE.AdditiveBlending,
  transparent: true,
  opacity: 0.8,
  sizeAttenuation: true
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

// Simplex noise approximation
function noise(x, y, z) {
  return Math.sin(x * 0.1) * Math.cos(y * 0.1) * Math.sin(z * 0.1);
}

// Gesture detection (simplified)
let handDetected = false;
let handOpenness = 0.5;
let handX = 0;
let handY = 0;
let handsCount = 0;
let lastHandTime = 0;

// Simple webcam-based motion detection
const video = document.getElementById('video');
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
canvas.width = 160;
canvas.height = 120;

let prevImageData = null;

async function initCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ 
      video: { width: 160, height: 120 } 
    });
    video.srcObject = stream;
    video.style.display = 'block';
    setTimeout(analyzeMotion, 1000);
  } catch (err) {
    console.log('Camera not available, using keyboard only');
    document.getElementById('gesture-display').textContent = 'KEYBOARD ONLY';
  }
}

function analyzeMotion() {
  if (video.readyState === video.HAVE_ENOUGH_DATA) {
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    if (prevImageData) {
      let motion = 0;
      let brightestX = 0;
      let brightestY = 0;
      let maxBrightness = 0;
      
      for (let i = 0; i < imageData.data.length; i += 4) {
        const diff = Math.abs(imageData.data[i] - prevImageData.data[i]) +
                     Math.abs(imageData.data[i + 1] - prevImageData.data[i + 1]) +
                     Math.abs(imageData.data[i + 2] - prevImageData.data[i + 2]);
        motion += diff;
        
        const brightness = imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2];
        if (brightness > maxBrightness) {
          maxBrightness = brightness;
          const pixelIndex = i / 4;
          brightestX = pixelIndex % canvas.width;
          brightestY = Math.floor(pixelIndex / canvas.width);
        }
      }
      
      motion = motion / (imageData.data.length / 4);
      
      if (motion > 15) {
        handDetected = true;
        lastHandTime = Date.now();
        handOpenness = Math.min(motion / 50, 1);
        handX = (brightestX / canvas.width - 0.5) * 2;
        handY = -(brightestY / canvas.height - 0.5) * 2;
        handDistance = motion / 100;
        
        if (motion > 40) {
          handsCount = 2;
        } else {
          handsCount = 1;
        }
        
        document.getElementById('gesture-display').textContent = 
          motion > 40 ? 'TWO HANDS' : handOpenness > 0.6 ? 'OPEN' : 'CLOSED';
      } else if (Date.now() - lastHandTime > 500) {
        handDetected = false;
        handsCount = 0;
        document.getElementById('gesture-display').textContent = 'NONE';
      }
    }
    
    prevImageData = imageData;
  }
  
  requestAnimationFrame(analyzeMotion);
}

initCamera();

// Shape morphing
function morphToShape(newShape) {
  if (newShape === currentShape) return;
  targetShape = newShape;
  morphProgress = 0;
  document.getElementById('shape-display').textContent = newShape.toUpperCase();
}

// Keyboard controls
document.addEventListener('keydown', (e) => {
  switch(e.key) {
    case '1': morphToShape('heart'); break;
    case '2': morphToShape('flower'); break;
    case '3': morphToShape('saturn'); break;
    case '4': morphToShape('fireworks'); break;
    case '5': morphToShape('galaxy'); break;
  }
});

// Gesture triggers
setInterval(() => {
  if (handsCount === 2 && Math.random() > 0.95) {
    const shapeNames = Object.keys(shapes);
    const randomShape = shapeNames[Math.floor(Math.random() * shapeNames.length)];
    morphToShape(randomShape);
  }
}, 100);

// Animation
let time = 0;
let fps = 60;
let lastTime = performance.now();
let frameCount = 0;

function animate() {
  requestAnimationFrame(animate);
  
  const currentTime = performance.now();
  const delta = currentTime - lastTime;
  frameCount++;
  
  if (frameCount % 30 === 0) {
    fps = Math.round(1000 / delta);
    document.getElementById('fps-display').textContent = fps;
  }
  
  lastTime = currentTime;
  time += 0.01;
  
  // Update gesture-based parameters
  if (handDetected) {
    gestureIntensity = THREE.MathUtils.lerp(gestureIntensity, handOpenness, 0.1);
    expansion = THREE.MathUtils.lerp(expansion, 0.5 + handDistance * 1.5, 0.1);
    swirl += handX * 0.05;
  } else {
    gestureIntensity = THREE.MathUtils.lerp(gestureIntensity, 0.3, 0.05);
    expansion = THREE.MathUtils.lerp(expansion, 1, 0.05);
  }
  
  // Morphing
  if (morphProgress < 1 && targetShape !== currentShape) {
    morphProgress += 0.01;
    if (morphProgress >= 1) {
      currentShape = targetShape;
      morphProgress = 0;
    }
  }
  
  // Update particles
  const posAttr = geometry.attributes.position;
  const colAttr = geometry.attributes.color;
  
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const i3 = i * 3;
    
    let [tx, ty, tz] = shapes[targetShape](i, PARTICLE_COUNT);
    let [cx, cy, cz] = shapes[currentShape](i, PARTICLE_COUNT);
    
    if (morphProgress > 0) {
      cx = THREE.MathUtils.lerp(cx, tx, morphProgress);
      cy = THREE.MathUtils.lerp(cy, ty, morphProgress);
      cz = THREE.MathUtils.lerp(cz, tz, morphProgress);
    }
    
    const x = posAttr.array[i3];
    const y = posAttr.array[i3 + 1];
    const z = posAttr.array[i3 + 2];
    
    const n = noise(x * 0.05 + time, y * 0.05, z * 0.05 + time) * gestureIntensity * 5;
    
    velocities[i3] += (cx * expansion - x) * 0.001 + n * 0.01;
    velocities[i3 + 1] += (cy * expansion - y) * 0.001 + n * 0.01;
    velocities[i3 + 2] += (cz * expansion - z) * 0.001;
    
    velocities[i3] *= 0.98;
    velocities[i3 + 1] *= 0.98;
    velocities[i3 + 2] *= 0.98;
    
    posAttr.array[i3] += velocities[i3];
    posAttr.array[i3 + 1] += velocities[i3 + 1];
    posAttr.array[i3 + 2] += velocities[i3 + 2];
    
    const color = new THREE.Color();
    const hue = (i / PARTICLE_COUNT + time * 0.1 + gestureIntensity * 0.2) % 1;
    color.setHSL(hue * 0.3 + 0.5, 1, 0.5 + gestureIntensity * 0.2);
    colAttr.array[i3] = color.r;
    colAttr.array[i3 + 1] = color.g;
    colAttr.array[i3 + 2] = color.b;
  }
  
  posAttr.needsUpdate = true;
  colAttr.needsUpdate = true;
  
  particles.rotation.y += 0.001 + swirl * 0.01;
  particles.rotation.x = Math.sin(time * 0.3) * 0.1;
  
  renderer.render(scene, camera);
}

// Window resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Remove loading screen
setTimeout(() => {
  const loading = document.getElementById('loading');
  if (loading) loading.style.display = 'none';
}, 2000);

animate();
</script>
</body>
</html>
