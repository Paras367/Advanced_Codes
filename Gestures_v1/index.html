<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gesture-Controlled 3D Particle Universe</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- Note: MediaPipe is NOT loaded unless on HTTPS -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #0c0e1d, #1a1c2d);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0ff;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(10, 12, 26, 0.75);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 16px;
            border: 1px solid rgba(92, 107, 192, 0.3);
            box-shadow: 0 0 20px rgba(92, 107, 192, 0.2);
            max-width: 320px;
        }
        .hud-title {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 12px;
            background: linear-gradient(90deg, #8a2be2, #4b0082);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }
        .hud-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(92, 107, 192, 0.2);
        }
        .hud-label { font-weight: 500; color: #a0a0ff; }
        .hud-value { font-weight: 600; color: #ffffff; }
        #camera-status {
            color: #ff6b6b;
            font-size: 13px;
            margin-top: 8px;
            text-align: center;
            font-style: italic;
        }
        .instructions {
            margin-top: 15px;
            font-size: 12px;
            color: #8080c0;
            text-align: center;
            padding-top: 10px;
            border-top: 1px solid rgba(92, 107, 192, 0.2);
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <div class="hud-title">PARTICLE UNIVERSE</div>
        <div class="hud-item">
            <span class="hud-label">Active Shape:</span>
            <span class="hud-value" id="active-shape">üåå Galaxy</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">Control Mode:</span>
            <span class="hud-value" id="control-mode">Keyboard</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">Particles:</span>
            <span class="hud-value">50,000</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">FPS:</span>
            <span class="hud-value" id="fps-counter">0</span>
        </div>
        <div id="camera-status">
            üìå Camera/gestures require HTTPS<br>(Use keyboard: 1-5 to switch shapes)
        </div>
        <div class="instructions">
            Keyboard Controls:<br>
            <strong>1</strong> ‚ù§Ô∏è Heart &nbsp; <strong>2</strong> üå∏ Flower &nbsp; <strong>3</strong> ü™ê Saturn<br>
            <strong>4</strong> üéÜ Fireworks &nbsp; <strong>5</strong> üåå Galaxy<br><br>
            Mouse: Drag to rotate ‚Ä¢ Scroll to zoom
        </div>
    </div>

    <script>
        // ======================
        // CONFIGURATION
        // ======================
        const PARTICLE_COUNT = 50000;
        const SHAPES = {
            heart: '‚ù§Ô∏è Heart',
            flower: 'üå∏ Flower',
            saturn: 'ü™ê Saturn',
            fireworks: 'üéÜ Fireworks',
            galaxy: 'üåå Galaxy'
        };
        let currentShape = 'galaxy';

        // ======================
        // THREE.JS SETUP
        // ======================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0c0e1d);
        scene.fog = new THREE.FogExp2(0x0c0e1d, 0.001);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 100;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // ======================
        // PARTICLE SYSTEM
        // ======================
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(180, 180, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(100, 100, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(50, 50, 150, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [r, g, b];
        }

        function generatePositions(shape) {
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const radius = 40;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                switch(shape) {
                    case 'heart':
                        const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                        const r = 16 * Math.pow(Math.sin(t), 3);
                        x = r * Math.cos(t) * (0.8 + Math.random() * 0.4);
                        y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * (0.8 + Math.random() * 0.4);
                        z = (Math.random() - 0.5) * 20;
                        break;
                    case 'flower':
                        const angle = (i / PARTICLE_COUNT) * Math.PI * 8;
                        const petalRadius = radius * (0.5 + 0.5 * Math.sin(angle * 4));
                        x = petalRadius * Math.cos(angle);
                        y = petalRadius * Math.sin(angle);
                        z = (Math.random() - 0.5) * 10;
                        break;
                    case 'saturn':
                        if (i < PARTICLE_COUNT * 0.7) {
                            const phi = Math.acos(2 * Math.random() - 1);
                            const theta = Math.random() * Math.PI * 2;
                            const r = radius * (0.7 + Math.random() * 0.3);
                            x = r * Math.sin(phi) * Math.cos(theta);
                            y = r * Math.sin(phi) * Math.sin(theta);
                            z = r * Math.cos(phi);
                        } else {
                            const ringAngle = Math.random() * Math.PI * 2;
                            const ringRadius = radius * (1.2 + Math.random() * 0.8);
                            x = ringRadius * Math.cos(ringAngle);
                            y = (Math.random() - 0.5) * 5;
                            z = ringRadius * Math.sin(ringAngle);
                        }
                        break;
                    case 'fireworks':
                        const burstAngle = Math.random() * Math.PI * 2;
                        const burstHeight = Math.random() * radius * 2;
                        const burstRadius = (Math.random() * radius) * (1 - burstHeight/(radius*2));
                        x = burstRadius * Math.cos(burstAngle);
                        y = burstHeight - radius;
                        z = (Math.random() - 0.5) * radius;
                        break;
                    case 'galaxy':
                    default:
                        const spiralAngle = (i / PARTICLE_COUNT) * Math.PI * 12;
                        const spiralRadius = radius * Math.sqrt(i / PARTICLE_COUNT);
                        x = spiralRadius * Math.cos(spiralAngle);
                        y = (Math.random() - 0.5) * 10;
                        z = spiralRadius * Math.sin(spiralAngle);
                        break;
                }
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }
            return positions;
        }

        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const rgb = hslToRgb(0.7 + (i / PARTICLE_COUNT) * 0.2, 0.8, 0.6);
            colors[i * 3] = rgb[0];
            colors[i * 3 + 1] = rgb[1];
            colors[i * 3 + 2] = rgb[2];
            sizes[i] = Math.random() * 2 + 1;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(generatePositions(currentShape), 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                pointTexture: { value: createParticleTexture() },
                time: { value: 0 },
                expansion: { value: 1.0 },
                turbulence: { value: 0.0 }
            },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                uniform float time;
                uniform float expansion;
                uniform float turbulence;
                void main() {
                    vColor = color;
                    vec3 pos = position;
                    pos += vec3(
                        sin(time * 0.5 + position.x) * turbulence,
                        cos(time * 0.3 + position.y) * turbulence,
                        sin(time * 0.4 + position.z) * turbulence
                    );
                    pos *= expansion;
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = size * (300.0 / -mvPosition.z) * (1.0 + turbulence * 0.5);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D pointTexture;
                varying vec3 vColor;
                void main() {
                    vec4 texColor = texture2D(pointTexture, gl_PointCoord);
                    if (texColor.a < 0.1) discard;
                    gl_FragColor = vec4(vColor * texColor.rgb, texColor.a);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthTest: true,
            transparent: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // ======================
        // POST-PROCESSING
        // ======================
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(new THREE.RenderPass(scene, camera));
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, 0.4, 0.85
        );
        composer.addPass(bloomPass);

        // ======================
        // INTERACTION & ANIMATION
        // ======================
        const clock = new THREE.Clock();
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;

        // Simulated hand parameters (for demo without camera)
        let expansion = 1.0;
        let turbulence = 0.0;
        let targetExpansion = 1.0;
        let targetTurbulence = 0.0;

        function changeShape(newShapeKey) {
            if (currentShape !== newShapeKey) {
                currentShape = newShapeKey;
                document.getElementById('active-shape').textContent = SHAPES[newShapeKey];
                geometry.attributes.position.array.set(generatePositions(newShapeKey));
                geometry.attributes.position.needsUpdate = true;
            }
        }

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            if (e.key === '1') changeShape('heart');
            else if (e.key === '2') changeShape('flower');
            else if (e.key === '3') changeShape('saturn');
            else if (e.key === '4') changeShape('fireworks');
            else if (e.key === '5') changeShape('galaxy');
            
            // Extra: Spacebar for explosion effect
            if (e.key === ' ') {
                targetExpansion = 2.5;
                targetTurbulence = 1.0;
                setTimeout(() => {
                    targetExpansion = 1.0;
                    targetTurbulence = 0.0;
                }, 800);
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            // Update FPS
            frameCount++;
            const now = performance.now();
            if (now - lastFpsUpdate >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
                document.getElementById('fps-counter').textContent = fps;
            }
            
            // Smoothly interpolate simulated hand parameters
            expansion += (targetExpansion - expansion) * 0.05;
            turbulence += (targetTurbulence - turbulence) * 0.05;
            
            // Update uniforms
            material.uniforms.time.value = elapsedTime;
            material.uniforms.expansion.value = expansion;
            material.uniforms.turbulence.value = turbulence;
            
            // Auto-rotate slowly
            controls.update();
            
            composer.render();
        }

        // Start animation
        animate();

        // Initial shape label
        document.getElementById('active-shape').textContent = SHAPES[currentShape];
    </script>
</body>
</html>
